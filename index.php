<?php

//0 массивы для тестов

//числовые (простые)
$ar1dim=[
    10,
    20,
    30,
    40,
    50,
    60
];

$ar2dim=[
    10,
    20,
    [
        30,
        40,
        50
    ],
    60
];

$ar3dim=[
    10,
    20,
    [
        30,
        [
            40,
            50
        ]
    ],
    60
];

//явно ассоциативные (сложные)

$as1dim=[
    '1Dim0Key'=>11,
    '1Dim1Key'=>22,
    33,
    '1Dim3Key'=>44,
    55
];

$as2dim=[
    '1Dim0Key'=>21,
    '1Dim1Key'=> 22,
    [
        '2Dim0Key'=>23,
        '2Dim1Key'=>24,
        25,
        '2Dim3Key'=>26
    ],
   '1Dim3Key'=>27
];

$as3dim=[
    '1Dim0Key'=>31,
    '1Dim1key'=>32,
    [
        '2Dim0Key'=>33,
        [
            '3Dim0Key'=>34,
            '3Dim1Key'=>35,
            '3Dim2Key'=>36
        ]
    ],
    '1Dim3Key'=>37
];

echo '<b> 0. массивы для тестов </b></br>';
echo 'одномерный ar1dim: <b>' . json_encode($ar1dim)  . '</b></br>';
echo ' двумерный ar2dim: <b>' . json_encode($ar2dim) . '</b></br>';
echo 'трёхмерный ar3dim: <b>' . json_encode($ar3dim) . '</b></br>';

echo 'одномерный as1dim: <b>' . json_encode($as1dim)  . '</b></br>';
echo ' двумерный as2dim: <b>' . json_encode($as2dim) . '</b></br>';
echo 'трёхмерный as3dim: <b>' . json_encode($as3dim) . '</b></br></br>';

//1. Создать функцию принимающую массив произвольной вложенности и определяющий любой элемент номер которого передан параметром во всех вложенных массивах.
echo '<b>1. Создать функцию принимающую массив произвольной вложенности и определяющий любой элемент номер которого передан параметром во всех вложенных массивах: </b></br>';
//процедура (нетипизированная функция) создаёт массив элементов с индексом $index, найденных во всех вложенных масивах
//сюда же будет попадать корневой элемент с заданным индексом, который потом будет отрезаться через array_shift()
//глобальная массив-переменная нужна для сохранения всех элементов с заданным индексом из всех вложенных массивов


function someElement(array $arr, int $index): void
{
    $i=0; //нужна чтоб получать порядковый номер элемента, не завязываясь на содержимое ключа
    global $fullArr;//собственно тут будут лежать все найденные элементы
    foreach ($arr as $k=>$v)//бежим циклом, ключ нужен, чтоб залить в результирующий массив
    {
        if (is_array($v))//наткнулся на вложенный
        {
            someElement($v, $index);//рекурсия
        }
        else
        {
            if ($i==$index) //если текущий элемент имеет порядковый номер, равный переданному
            {
                $fullArr[]=[$k=>$v];//добавляю новюую пару ключ-значение в выходной массив
            }
        }
        $i++;//следующий индекс
    }
//ничего не возвразщается
}

echo '
## процедура отдаёт массив с искомыми элементами, но туда может попадать и подходящий элемент из основного массива </br>
## если пытаться убрать его, то вылезет неоднозначность трактовки результатов из-за неоднозначности условия задачи. </br>
## если массив пустой - значит не нашел элементов с нужным порядковым номером (от нуля!)</br>
## проверок внутри процедуры на переданный пустой массив, на нечисловой порядковый номер и т.д. не делаю, т.к. не было в задании </br>';

//много текста для проверки процедуры с разными массивами:
//индексы меняются от 0 до 6 чтоб показать как вырождаются результаты
for ($indexPos=0; $indexPos<7; $indexPos++)
{
   echo "</br> выводим данные для искомого элемента с порядковым номером = $indexPos : </br></br>";
    //с масисвами $ar1dim, $ar2dim, $ar3dim
    for ($i = 1; $i < 4; $i++)
    {
        $fullArr = array();//это для отдачи результата ()
        $arr = 'ar' . $i . 'dim';//имя переменной переменной для внутрицикловой обработки
        someElement(${$arr}, $indexPos);//ВОЖДЕЛЕННАЯ ФУНКЦИЯ ПОИСКА
        echo 'для массива ' . 'ar' . $i . 'dim :' . json_encode($fullArr) . '</br>';
    }
    //с масисвами $as1dim, $as2dim, $as3dim
    for ($i = 1; $i < 4; $i++)
    {
        $fullArr = array();
        $arr = 'as' . $i . 'dim';//имя переменной переменной для внутрицикловой обработки
        someElement(${$arr}, $indexPos);//ВОЖДЕЛЕННАЯ ФУНКЦИЯ ПОИСКА
        echo 'для массива ' . 'as' . $i . 'dim :' . json_encode($fullArr) . '</br>';
    }

}


//2. Создать функцию которая считает все буквы b в переданной строке, в случае если передается не строка функция должна возвращать false
echo '</br></br><b> 2. Создать функцию которая считает все буквы b в переданной строке, в случае если передается не строка функция должна возвращать false </b></br>
##для не строк вместо false видна пустота, т.к. логический тип данных не отображается через echo </br></br>';

//тестовые строки
$string1='build best brake before better booster';
$string2='no more find ';
$string3=99.9;
$string4="999burn";
$string5='only one b inside';

//искомый символ:
$letter='b';

function findLetter($inputString, $charForFind): bool|int
{
    return (!is_string($inputString) ? false : substr_count($inputString,$charForFind) );
}

echo 'ниже дан результат в формате: строка => число букв b: </br></br>';
echo " $string1 => <b>". (findLetter($string1,$letter)).'</b></br>';
echo " $string2 => <b>". (findLetter($string2,$letter)).'</b></br>';
echo " $string3 => <b>". (findLetter($string3,$letter)).'</b></br>';
echo " $string4 => <b>". (findLetter($string4,$letter)).'</b></br>';
echo " $string5 => <b>". (findLetter($string5,$letter)).'</b></br>';


//3 Создать функцию которая считает сумму значений всех элементов массива произвольной глубины
echo '</br></br><b> 3.Создать функцию которая считает сумму значений всех элементов массива произвольной глубины</b></br></br>';

function user($arr)
{
    $sum=0;
    foreach ($arr as $v)
    {
        if (is_array($v))
        {
            $sum=$sum+user($v);
        }
        else
        {
            $sum=$sum+$v;// echo $v . '</br>';
        }
    }
    return $sum;
}

//echo 'тест функции суммы на одномерном массиве: <b>' . user($ar1dim) . '</b></br>';
//echo 'тест функции суммы на двумерном массиве:  <b>' . user($ar2dim) . '</b></br>';
//echo 'тест функции суммы на трёхмерном массиве: <b>' . user($ar3dim) . '</b></br>';
echo 'для массива $ar1dim = '.json_encode($ar1dim) . ': <b>' . user($ar1dim) . '</b></br>';
echo 'для массива $ar2dim = '.json_encode($ar2dim) . ': <b>' . user($ar2dim) . '</b></br>';
echo 'для массива $ar3dim = '.json_encode($ar3dim) . ': <b>' . user($ar3dim) . '</b></br>';

echo '</br>';

//4. Создать функцию которая определит сколько квадратов меньшего размера можно вписать в квадрат большего размера размер возвращать в float
echo '<b> 4. Создать функцию которая определит сколько квадратов меньшего размера можно вписать в квадрат большего размера размер возвращать в float: </b></br>
# трактую, что размер квадрата - это длина его стороны </br>';

function howMuchSquare(float $bigSize, float $smallSize):float
{
    //по длине стороны вычисляю площадь большого и малого квадратов
    //возвращаю отношение площадей - это и будет число
    //красиво НЕ делаю: будет писать в том числе, к примеру, ноль целых 5 десятых,
    // если площадь малого квадрата окажется больше площади большого
    $bigS=$bigSize*$bigSize;
    $smallS=$smallSize*$smallSize;
    return (($smallS<>0) ? $bigS/$smallS : 0) ;

}

//массив с размерами сторон для тестов функции
$arSq =
    [
        10=>1,
        1=>0.1,
        100=>50,
        1000=>2000,
        9=>3
    ];
foreach ($arSq as $big=>$small)
{
    echo "в квадрат со стороной $big влезет <b>" . howMuchSquare($big, $small) . "</b> квадратов со стороной $small </br>";
}