<?php

//0 массивы для тестов

//числовые (простые)
$ar1dim=[
    10,
    20,
    30,
    40,
    50,
    60
];

$ar2dim=[
    10,
    20,
    [
        30,
        40,
        50
    ],
    60
];

$ar3dim=[
    10,
    20,
    [
        30,
        [
            40,
            50
        ]
    ],
    60
];

//явно ассоциативные (сложные)

$as1dim=[
    '0Dim0Key'=>11,
    '0Dim1Key'=>22,
    33,
    '0Dim3Key'=>44,
    55
];

$as2dim=[
    '0Dim0Key'=>21,
    '0Dim1Key'=> 22,
    [
        '1Dim0Key'=>23,
        '1Dim1Key'=>24,
        25,
        '1Dim3Key'=>26
    ],
   '0Dim3Key'=>27
];

$as3dim=[
    '0Dim0Key'=>31,
    '0Dim1key'=>32,
    [
        '1Dim0Key'=>33,
        '1Dim1Key'=>36,
        [
            '2Dim0Key'=>34,
            '2Dim1Key'=>35,
            '2Dim2Key'=>36,
            [
                '3dim0key'=>90]
        ],
          '1Dim3Key'=>36,
    ],
    '0Dim3Key'=>37,
    '0Dim4Key'=>377
];

echo '<b> 0. массивы для тестов </b></br>';
echo 'одномерный ar1dim: <b>' . json_encode($ar1dim)  . '</b></br>';
echo ' двумерный ar2dim: <b>' . json_encode($ar2dim) . '</b></br>';
echo 'трёхмерный ar3dim: <b>' . json_encode($ar3dim) . '</b></br>';

echo 'одномерный as1dim: <b>' . json_encode($as1dim)  . '</b></br>';
echo ' двумерный as2dim: <b>' . json_encode($as2dim) . '</b></br>';
echo 'трёхмерный as3dim: <b>' . json_encode($as3dim) . '</b></br></br>';

//1. Создать функцию принимающую массив произвольной вложенности и определяющий любой элемент номер которого передан параметром во всех вложенных массивах.
echo '<b>1. Создать функцию принимающую массив произвольной вложенности и определяющий любой элемент номер которого передан параметром во всех вложенных массивах: </b></br>';

//ищет элементы по порядковому номеру и формирует строку из них вида ключ-->значение
//тут же третим параметров вызова номер вложенности (от нуля)
function someElement(array $arr2, int $index2, int $dim=0): string
{
    $s = "";
    $i = 0;
    foreach ($arr2 as $k => $v)
    {
        if (is_array($v))
        {
            $s = $s . someElement($v, $index2,$dim+1);
        }
        else
            if ($index2 == $i)
            {
                $s = $s  . "->". $k . "->" . $v ."->". $dim;
            }
        $i++;
    }

    return $s;
}

function resultFormat(array $arr, int $index):array
{
    $c=array();
    $b=someElement($arr, $index);
    if (strlen($b)>0)
    {
        $b = substr($b, 2);
        $b = explode("->", $b);
        $z = 0;
        for ($i = 0; $i < count($b); $i = $i + 3)
        {
       if ($b[$i+2]<>0) //отбрасываю корневые элементы
       {
           $c[$b[$i + 2]] = [$b[$i] => $b[$i + 1]];
           $z++;
       }
       }
       // return $c;

    }
   // else
    {
        return $c;
    }
}



echo '
## теперь юзается две функции: одна формирует строку с парами ключ--значение, а вторая - создаёт массив</br>
вид результата:НОМЕР ВЛОЖЕННОСТИ = [ЭЛЕМЕНТ ИЗ ИСХОДНОГО МАССИВА В ВИДЕ ПАРЫ КЛЮЧ->ЗНАЧНИЕ]  </br>
## массив всегда пуст для массивов без вложений (по условию задачи нужны именно вложенные)  </br>
## массив может быть пустой если не найдены эдлементы </br>
## глобальные переменные всё также не юзаются</br></br>

!!! порядковый номер при вызове функции - считается от нуля!</br>
!!! вложенность считается от нуля (0 -корневой массив, 1 - первая степень вложенности и т.д) </br></br> 

';

//много текста для проверки процедуры с разными массивами:
//индексы меняются от 0 до 6 чтоб показать как вырождаются результаты

for ($indexPos=0; $indexPos<5; $indexPos++)
{
   echo "</br> выводим данные для искомого элемента с порядковым номером = $indexPos : </br></br>";
    //с масисвами $ar1dim, $ar2dim, $ar3dim
    for ($i = 1; $i < 4; $i++)
    {
        $arr = 'ar' . $i . 'dim';//имя переменной переменной для внутрицикловой обработки
  echo 'для массива ' . 'ar' . $i . 'dim :' . json_encode(resultFormat(${$arr}, $indexPos)) . '</br>';
    }
    //с масисвами $as1dim, $as2dim, $as3dim
    for ($i = 1; $i < 4; $i++)
    {
        $arr = 'as' . $i . 'dim';//имя переменной переменной для внутрицикловой обработки
     echo 'для массива ' . 'as' . $i . 'dim :' . json_encode(resultFormat(${$arr}, $indexPos)) . '</br>';
    }
  //
   //
}




//2. Создать функцию которая считает все буквы b в переданной строке, в случае если передается не строка функция должна возвращать false
echo '</br></br><b> 2. Создать функцию которая считает все буквы b в переданной строке, в случае если передается не строка функция должна возвращать false </b></br>
##для не строк вместо false видна пустота, т.к. логический тип данных не отображается через echo </br></br>';

//тестовые строки
$string1='build best brake before better booster';
$string2='no more find ';
$string3=99.9;
$string4="999burn";
$string5='only one b inside';

//искомый символ:
$letter='b';

function findLetter($inputString, $charForFind): bool|int
{
    return (!is_string($inputString) ? false : substr_count($inputString,$charForFind) );
}

echo 'ниже дан результат в формате: строка => число букв b: </br></br>';
echo " $string1 => <b>". (findLetter($string1,$letter)).'</b></br>';
echo " $string2 => <b>". (findLetter($string2,$letter)).'</b></br>';
echo " $string3 => <b>". (findLetter($string3,$letter)).'</b></br>';
echo " $string4 => <b>". (findLetter($string4,$letter)).'</b></br>';
echo " $string5 => <b>". (findLetter($string5,$letter)).'</b></br>';


//3 Создать функцию которая считает сумму значений всех элементов массива произвольной глубины
echo '</br></br><b> 3.Создать функцию которая считает сумму значений всех элементов массива произвольной глубины</b></br></br>';

function user($arr)
{
    $sum=0;
    foreach ($arr as $v)
    {
        if (is_array($v))
        {
            $sum=$sum+user($v);
        }
        else
        {
            $sum=$sum+$v;// echo $v . '</br>';
        }
    }
    return $sum;
}

//echo 'тест функции суммы на одномерном массиве: <b>' . user($ar1dim) . '</b></br>';
//echo 'тест функции суммы на двумерном массиве:  <b>' . user($ar2dim) . '</b></br>';
//echo 'тест функции суммы на трёхмерном массиве: <b>' . user($ar3dim) . '</b></br>';
echo 'для массива $ar1dim = '.json_encode($ar1dim) . ': <b>' . user($ar1dim) . '</b></br>';
echo 'для массива $ar2dim = '.json_encode($ar2dim) . ': <b>' . user($ar2dim) . '</b></br>';
echo 'для массива $ar3dim = '.json_encode($ar3dim) . ': <b>' . user($ar3dim) . '</b></br>';

echo '</br>';

//4. Создать функцию которая определит сколько квадратов меньшего размера можно вписать в квадрат большего размера размер возвращать в float
echo '<b> 4. Создать функцию которая определит сколько квадратов меньшего размера можно вписать в квадрат большего размера размер возвращать в float: </b></br>
# трактую, что размер квадрата - это длина его стороны </br>';

function howMuchSquare(float $bigSize, float $smallSize):float
{
    //по длине стороны вычисляю площадь большого и малого квадратов
    //возвращаю отношение площадей - это и будет число
    //красиво НЕ делаю: будет писать в том числе, к примеру, ноль целых 5 десятых,
    // если площадь малого квадрата окажется больше площади большого
    $bigS=$bigSize*$bigSize;
    $smallS=$smallSize*$smallSize;
    return (($smallS<>0) ? $bigS/$smallS : 0) ;

}

//массив с размерами сторон для тестов функции
$arSq =
    [
        10=>1,
        1=>0.1,
        100=>50,
        1000=>2000,
        9=>3
    ];
foreach ($arSq as $big=>$small)
{
    echo "в квадрат со стороной $big влезет <b>" . howMuchSquare($big, $small) . "</b> квадратов со стороной $small </br>";
}